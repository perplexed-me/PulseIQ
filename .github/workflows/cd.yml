name: CD Deploy to Docker Hub & Azure

on:
  workflow_run:
    workflows: ["CI Build & Test"]
    types: [completed]
    branches: [main]

jobs:
  build-and-push:
    if: github.event.workflow_run.conclusion == 'success'
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v3
        with:
          ref: ${{ github.event.workflow_run.head_sha }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Extract metadata for backend
        id: meta-backend
        uses: docker/metadata-action@v5
        with:
          images: ${{ secrets.DOCKER_USERNAME }}/pulseiq-backend
          tags: |
            type=ref,event=branch
            type=sha,prefix={{branch}}-
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Extract metadata for frontend
        id: meta-frontend
        uses: docker/metadata-action@v5
        with:
          images: ${{ secrets.DOCKER_USERNAME }}/pulseiq-frontend
          tags: |
            type=ref,event=branch
            type=sha,prefix={{branch}}-
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Build and push backend image
        uses: docker/build-push-action@v5
        with:
          context: ./backend
          push: true
          tags: ${{ steps.meta-backend.outputs.tags }}
          labels: ${{ steps.meta-backend.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Build and push frontend image
        uses: docker/build-push-action@v5
        with:
          context: ./frontend
          file: ./frontend/Dockerfile.production
          push: true
          tags: ${{ steps.meta-frontend.outputs.tags }}
          labels: ${{ steps.meta-frontend.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            VITE_BACKEND_URL=http://${{ secrets.AZURE_SSH_HOST }}:8085
            VITE_FIREBASE_API_KEY=${{ secrets.VITE_FIREBASE_API_KEY }}
            VITE_FIREBASE_AUTH_DOMAIN=${{ secrets.VITE_FIREBASE_AUTH_DOMAIN }}
            VITE_FIREBASE_PROJECT_ID=${{ secrets.VITE_FIREBASE_PROJECT_ID }}
            VITE_FIREBASE_STORAGE_BUCKET=${{ secrets.VITE_FIREBASE_STORAGE_BUCKET }}
            VITE_FIREBASE_MESSAGING_SENDER_ID=${{ secrets.VITE_FIREBASE_MESSAGING_SENDER_ID }}
            VITE_FIREBASE_APP_ID=${{ secrets.VITE_FIREBASE_APP_ID }}
            VITE_FIREBASE_MEASUREMENT_ID=${{ secrets.VITE_FIREBASE_MEASUREMENT_ID }}

  deploy-to-azure:
    needs: build-and-push
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Deploy to Azure VM
        uses: appleboy/ssh-action@v1
        with:
          host: ${{ secrets.AZURE_SSH_HOST }}
          username: ${{ secrets.AZURE_SSH_USER }}
          key: ${{ secrets.AZURE_SSH_PRIVATE_KEY }}
          script: |
            set -e

            # Create application directory
            mkdir -p ~/pulseiq-app
            cd ~/pulseiq-app

            # Create environment file for production
            cat > .env.azure << EOF
            DOCKER_USERNAME=${{ secrets.DOCKER_USERNAME }}
            DB_PASSWORD=${{ secrets.DB_PASSWORD }}
            JWT_SECRET=${{ secrets.JWT_SECRET }}
            FRONTEND_URL=http://${{ secrets.AZURE_SSH_HOST }}:8080
            BACKEND_URL=http://${{ secrets.AZURE_SSH_HOST }}:8085
            FIREBASE_ENABLED=true
            VITE_FIREBASE_API_KEY=${{ secrets.VITE_FIREBASE_API_KEY }}
            VITE_FIREBASE_AUTH_DOMAIN=${{ secrets.VITE_FIREBASE_AUTH_DOMAIN }}
            VITE_FIREBASE_PROJECT_ID=${{ secrets.VITE_FIREBASE_PROJECT_ID }}
            VITE_FIREBASE_STORAGE_BUCKET=${{ secrets.VITE_FIREBASE_STORAGE_BUCKET }}
            VITE_FIREBASE_MESSAGING_SENDER_ID=${{ secrets.VITE_FIREBASE_MESSAGING_SENDER_ID }}
            VITE_FIREBASE_APP_ID=${{ secrets.VITE_FIREBASE_APP_ID }}
            VITE_FIREBASE_MEASUREMENT_ID=${{ secrets.VITE_FIREBASE_MEASUREMENT_ID }}
            EOF

            # Download the latest docker-compose.azure.yml from the repository
            echo "Downloading latest docker-compose.azure.yml..."
            curl -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
                 -H "Accept: application/vnd.github.v3.raw" \
                 -o docker-compose.azure.yml \
                 "https://api.github.com/repos/${{ github.repository }}/contents/docker-compose.azure.yml?ref=main"

            # Download the latest init-schema.sql from the repository
            echo "Downloading latest init-schema.sql..."
            curl -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
                 -H "Accept: application/vnd.github.v3.raw" \
                 -o init-schema.sql \
                 "https://api.github.com/repos/${{ github.repository }}/contents/backend/init-schema.sql?ref=main"

            # Create Firebase service account file
            echo '${{ secrets.FIREBASE_SERVICE_ACCOUNT_JSON }}' > firebase-service-account.json

            # Ensure firewall allows HTTP traffic
            echo "Configuring firewall for HTTP traffic..."
            sudo ufw allow 8080/tcp || true
            sudo ufw allow 8085/tcp || true
            sudo ufw status || true

            # Pull latest images
            echo "Pulling latest images..."
            docker-compose -f docker-compose.azure.yml --env-file .env.azure pull

            # Stop existing containers
            echo "Stopping existing containers..."
            docker-compose -f docker-compose.azure.yml down || true

            # Clean up unused resources
            docker system prune -f || true

            # Start the application
            echo "Starting PulseIQ application..."
            docker-compose -f docker-compose.azure.yml --env-file .env.azure up -d

            # Wait for services to be healthy
            echo "Waiting for services to be healthy..."
            timeout 300 bash -c '
              while true; do
                if docker-compose -f docker-compose.azure.yml ps | grep -q "healthy"; then
                  echo "Services are healthy!"
                  break
                fi
                echo "Waiting for services to start..."
                sleep 10
              done
            '

            # Show service status
            echo "=== Service Status ==="
            docker-compose -f docker-compose.azure.yml ps

            # Show recent logs
            echo "=== Recent Logs ==="
            docker-compose -f docker-compose.azure.yml logs --tail=20

            # Test connectivity
            echo "=== Testing Connectivity ==="
            echo "Testing backend health endpoint..."
            curl -f http://localhost:8085/actuator/health || echo "Backend health check failed"

            echo "Testing frontend..."
            curl -f http://localhost:8080/ || echo "Frontend connectivity failed"

            echo "Testing external connectivity..."
            curl -f http://127.0.0.1:8080/ || echo "External frontend test failed"

            # Show network and port information
            echo "=== Network Information ==="
            netstat -tlnp | grep -E ':(8080|8085)' || echo "Ports not listening"
            docker network ls
            docker inspect pulseiq_frontend | grep -A 5 NetworkSettings || true

            echo "âœ… Deployment completed successfully!"
            echo "Frontend: http://${{ secrets.AZURE_SSH_HOST }}:8080"
            echo "Backend: http://${{ secrets.AZURE_SSH_HOST }}:8085"
